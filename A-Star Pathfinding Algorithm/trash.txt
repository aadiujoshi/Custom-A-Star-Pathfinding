old minnode
// if(node.nodes == null) 
        //     if(node.fCost < smallestFCostNode.fCost)
        //         return node;
        //     else if(node.fCost > smallestFCostNode.fCost)
        //         return smallestFCostNode;
        //     else if(node.fCost == smallestFCostNode.fCost){ System.out.println(node + "  " + smallestFCostNode);
        //         return Math.min(node.hCost, smallestFCostNode.hCost) == node.hCost ? node : smallestFCostNode;}

        // int smallestFCost = smallestFCostNode.fCost;

        // for(int i = 0; i < node.nodes.length; i++)
        // {
        //     if(node.nodes[i] == null) continue;
        //     int otherSmallest = smallestFCost(node.nodes[i], smallestFCostNode).fCost;
        //     smallestFCost = otherSmallest < smallestFCost ? otherSmallest : smallestFCost;
        // }

        // if(node.fCost < smallestFCostNode.fCost)
        //     return node;
        // else if(node.fCost > smallestFCostNode.fCost)
        //     return smallestFCostNode;
        // else if(node.fCost == smallestFCostNode.fCost){ System.out.println(node + "  " + smallestFCostNode);
        //     return Math.min(node.hCost, smallestFCostNode.hCost) == node.hCost ? node : smallestFCostNode;}

        // return null;
        // // return node.fCost < smallestFCost ? node : smallestFCostNode;

find node at method

        // get node at code
        // Node sNode = startingNode;
        // for(int i = 0; i < nodeAddress.size(); i++)
        //     sNode = sNode.nodes[nodeAddress.get(i)];
        // return sNode;



other old minnode
if(node.nodes == null) return node;

        int j = 0;
        
        // for(Node n: node.nodes)
        //     System.out.println("\t" + n);

        while(node.nodes[j] == null) j++; //find first non-null subnode
        Node smallestCostNode = node.nodes[j];

        for(int i = 0; i < node.nodes.length; i++)
        {
            if(node.nodes[i] == null) continue;
            Node otherSmallest = smallestCost(node.nodes[i]);

            if(otherSmallest.fCost < smallestCostNode.fCost)
                smallestCostNode = otherSmallest;
            else if(otherSmallest.fCost > smallestCostNode.fCost)
                smallestCostNode = otherSmallest;
            else if(otherSmallest.fCost == smallestCostNode.fCost)
                smallestCostNode = Math.min(otherSmallest.hCost, smallestCostNode.hCost) == otherSmallest.hCost ? otherSmallest : smallestCostNode;
            System.out.println(smallestCostNode);
        }

        return smallestCostNode;