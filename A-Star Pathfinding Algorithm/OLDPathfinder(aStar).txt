package src;
import java.awt.Point;
import java.util.ArrayList;

public class Pathfinder 
{
    public Pathfinder(){}
    
    public byte[][] findBestPath(byte[][] grid)
    {
        //FIND START AND END OF PATH
        Point start = null;
        Point end = null;
        for(int r = 0; r < grid.length; r++)
            for(int c = 0; c < grid[0].length; c++)
            {
                if(grid[r][c] == 2)
                    start = new Point(c, r);
                if(grid[r][c] == 3)
                    end = new Point(c, r);
            }
        if(start == null || end == null)
            return grid;
        
        //--------------------------------------------------------------------------------------------
        //pathfinding
        //--------------------------------------------------------------------------------------------
        
        ArrayList<Integer> startAddress = new ArrayList<>();
        startAddress.add(0);
        Node startingNode = new Node(start, false, -1, end, startAddress);
        startingNode.calculateSubnodes(grid);

        // int cycles = 0;

        while(true)
        {
            Node sampleNode = smallestCost(startingNode);
            searchNode(sampleNode, grid, sampleNode.fCost, end);

            // System.out.println
            // System.out.println(sampleNode.p);

            // System.out.println(sampleNode);
            // System.out.println(startingNode);
            // for(Node n: startingNode.nodes)
            //     System.out.println("\t" + n);
            // System.out.println();

            // System.out.println(sampleNode);

            if(reachedEndpoint(sampleNode, end))
            {
                setNodeAt(startingNode, sampleNode, sampleNode.nodeAddress, 0);
                writeNodeToGrid(startingNode, grid);
                break;
            }
            // cycles++;
        }

        System.out.println("ended");
        return grid;
    }

    private void writeNodeToGrid(Node node, byte[][] grid) 
    {
        if(grid[(int)node.p.getY()][(int)node.p.getX()] == 0)
            grid[(int)node.p.getY()][(int)node.p.getX()] = 4;

        if(node.nodes != null)
            for(Node n : node.nodes)
                if(n != null)
                    writeNodeToGrid(n, grid);
    }

    public boolean reachedEndpoint(Node node, Point end)
    {
        if(node.p.equals(end)) return true;
        if(node.nodes == null) return false;

        for(Node n : node.nodes)
            if(n != null)
                if(reachedEndpoint(n, end))
                    return true;

        return false;
    }

    public Node smallestCost(Node node)
    {
        ArrayList<Node> nodeList = nodeAsList(node, new ArrayList<Node>());

        int non_nullIndex = 0;
        while(nodeList.get(non_nullIndex) == null) non_nullIndex++;

        Node leastCostNode = nodeList.get(non_nullIndex);

        for(int i = 0; i < nodeList.size(); i++)
        {
            if(nodeList.get(i) == null) continue;
            
            Node other = nodeList.get(i);

            if(other.fCost < leastCostNode.fCost)
                leastCostNode = other;
            else if(other.fCost > leastCostNode.fCost)
                leastCostNode = other;
            else if(other.fCost == leastCostNode.fCost)
                leastCostNode = Math.min(other.hCost, leastCostNode.hCost) == other.hCost ? other : leastCostNode;
            // System.out.println(leastCostNode);
        }
        System.out.println(leastCostNode);

        return leastCostNode;
    }

    public ArrayList<Node> nodeAsList(Node node, ArrayList<Node> nodeList)
    {
        if(node.nodes != null)
            for(Node n : node.nodes)
                if(n != null)
                    nodeAsList(n, nodeList);
        if(node.nodes == null)
            nodeList.add(node);
        return nodeList;
    }   

    public Node setNodeAt(Node rootNode, Node node, ArrayList<Integer> nodeAddress, int i)
    {
        if(i != nodeAddress.size()-1) //end of array -> correct node
        {
            // System.out.println(rootNode.p);
            setNodeAt(rootNode.nodes[nodeAddress.get(i)], node, nodeAddress, i+1);
        }
        else
            rootNode = node;
        return rootNode;
    }

    public Node searchNode(Node node, byte[][] grid, int prevSmallestFCost, Point end)
    {
        //must return original node | only the subnodes are altered
        //generate subnodes
        //check for end point -> true -> return else keep going
        //sort by least to greatest fcost
        //check if the lowest fcost of the subnodes is more or less than the parent node
            //less -> keep going
            //more -> return

        node.calculateSubnodes(grid);

        // System.out.println(node);

        Node[] nodes = node.nodes;

        for(Node n : nodes)
            if(n != null)
                if(n.p.equals(end))
                    return node;
        
        for(int i = 0; i < nodes.length; i++)
            for(int j = i+1; j < nodes.length; j++)
                if(nodes[i] != null && nodes[j] != null && nodes[j].fCost < nodes[i].fCost) //sort by fCost
                {
                    Node temp = nodes[i];
                    nodes[i] = nodes[j];
                    nodes[j] = temp;
                }

        int j = 0;
        while(nodes[j] == null) j++;

        if(nodes[j].fCost > prevSmallestFCost) 
            return node;

        for(Node n : nodes)
            if(n != null)
                searchNode(n, grid, nodes[j].fCost, end);

        return node;
    }
}
