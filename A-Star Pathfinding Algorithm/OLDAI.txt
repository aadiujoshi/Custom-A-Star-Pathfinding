import java.awt.Point;
import java.util.Arrays;

public class AI 
{
    public AI(){}
    
    // int stackID = 0;

    public byte[][] findBestPath(byte[][] grid)
    {
        //FIND START AND END OF PATH
        Point start = null;
        Point end = null;
        for(int r = 0; r < grid.length; r++)
            for(int c = 0; c < grid[0].length; c++)
            {
                if(grid[r][c] == 2)
                    start = new Point(r, c);
                if(grid[r][c] == 3)
                    end = new Point(r, c);
            }
        if(start == null || end == null)
            return grid;
        
        Node finalPath = pathfind(new Node(start, false, -1, end), grid, end);
        
        return grid;
    }

    public Node pathfind(Node node, byte[][] grid, Point end)
    {
        // if(stackID == 1000)
        //     return node;
        // stackID++;

        Node[] nodes = node.nodes;
        node.calculateSubnodes(grid);
        for(int i = 0; i < nodes.length; i++)
            if(nodes[i] != null && nodes[i].p.getX() == end.getX() && nodes[i].p.getY() == end.getY())
                return node;

        for(int i = 0; i < nodes.length; i++)
            for(int j = i+1; j < nodes.length; j++)
                if(nodes[i] != null && nodes[j] != null && nodes[j].fCost < nodes[i].fCost) //sort by fCost
                {
                    Node temp = nodes[i];
                    nodes[i] = nodes[j];
                    nodes[j] = temp;
                }
        
        // System.out.println(node.p);
        
        // for(Node n: node.nodes)
        //     System.out.println(n);

        // if(true)
        //     return node;
        
        //write onto grid
        for(Node n : nodes)
            if(n != null)
                grid[(int)n.p.getX()][(int)n.p.getY()] = 4;

        //search in order of fCost
        for(Node n : nodes)
            return pathfind(n, grid, end);
        
        return node;
    }
}
