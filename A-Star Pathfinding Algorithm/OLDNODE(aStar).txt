package src;
import java.awt.Point;
import java.util.ArrayList;

public class Node 
{
    /*
     *    1  2  3
     *    4  N  5
     *    6  7  8
     */
    
    Node[] nodes; //null until calculateSubnodes() is called

    ArrayList<Integer> nodeAddress;

    Point p; // X IS COLUMNS AND Y IS ROWS
    Point end;

    int gCost;
    int hCost;
    int fCost;

    public Node(Point p, boolean diagonal, int prevGCost, Point end, ArrayList<Integer> address)
    {
        this.p = p;
        this.gCost = prevGCost == -1 ? 0 : diagonal?prevGCost+14:prevGCost+10;
            int dx = Math.abs(p.x-end.x);
            int dy = Math.abs(p.y-end.y);
        this.hCost = 10*(dx+dy) + (14-2*10) * Math.min(dx,dy);
        this.fCost = hCost + gCost;
        this.end = end;

        this.nodeAddress = address;
    }

    public void calculateSubnodes(byte[][] grid)
    {
        nodes = new Node[8];
        int i = 0;
        for(int r = (int)p.getX()-1; r <= p.getX()+1; r++)
            for(int c = (int)p.getY()-1; c <= p.getY()+1; c++)
            {
                if(r == p.getX() && c == p.getY())
                    continue;
                if(r >= 0 && r < grid.length && c >= 0 && c < grid[0].length && grid[r][c] == 0)
                {
                    ArrayList<Integer> subnodeAddress = new ArrayList<>(this.nodeAddress);
                    subnodeAddress.add(i);

                    nodes[i] = new Node(new Point(r, c), 
                    (p.getX()!=r)&&(p.getY()!=c)?true:false, gCost, end, subnodeAddress);
                }
                i++;
            }
    }

    public String toString()
    {
        return p + "  " + gCost + "  " + hCost + "  " + fCost + "";
    }
}
